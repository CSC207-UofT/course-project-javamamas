## Scenario Walk-Through

In order to achieve our goal of creating a program that allows users to play Monopoly among other local players, we created a CRC model of our program to help visualize how we want our program to work. Our program starts with a Player which stores the player name and the tiles with respective houses or hotels for each tile. Additionally, the Player class stores their balance, which determines what the player can afford and whether they can keep playing. Players in this game can own tiles, which is represented by the abstract Tile class. The Tile class is a parent class to BuyableTile, CommunityChestTile, PrisionTile, StartTile, and GoToJailTile, which are each unique tiles in the game that extend the Tile parent class. The TileController class manages the Tiles part of the game. This class controls which players own which tiles, and what happens to players that land on specific tiles. The TileController class can also allow or block a player from purchasing a tile. The PropertyChecker class checks to see if a player can buy a specific tile, which refers to the balance the player has and whether that player can afford the purchase. 

With all these purchases going on in the game, we have the Bank class to manage and keep track of what can be bought in the game. This class stores how many tiles and houses/hotels are able to be bought. As the game goes buy and players buy, sell, and pay rent on tiles, some players will run out of money. In our monopoly game, we deem a player unfit to continue playing if they are bankrupt. To keep track of a player’s bankrupt and financial status, we have the PlayerStatus class. This class checks if a player is bankrupt, and checks a player’s net worth which includes the sum of money the player has left and their tile values. With all these classes keeping track of statuses and managing purchases, we have a MoveController class to manage the moves during the game. This controller class controls whose turn it is in the game, the dice rolls, the current player positions on the board, and where the players can move respective to their dice rolls. The MoveController class also assigns a turn number for each player to help the game run more smoothly. With all these classes keeping the game functioning properly, we determine whether the game is finished with the GameStatus class. This use case class checks whether the game has ended if all the buyable tiles are sold, which is kept track by the bank. Additionally, the GameStatus class checks if all the players are bankrupt, which also indicates the game is over. Finally, we have our Main class which implements the GUI for the game and interacts with all of our classes to keep the game running. 

